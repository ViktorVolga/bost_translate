Boost.Asio может быть использован для выполнения как синхронных так и асинхронных операций вода вывода на таких объектах как сокет.
Перед использованием библиотеки полезно ознакомится с общими принципами различных частей библиотеки, вашей программы и как они работают вместе.
Как вводный пример давайте рассмотрим что происходит когда вы производите операцию connect на сокете. Мы должны начать обучение с однопоточных операций.
Ваша программа <-> I/O объект (сокет) <-> I/O execution context (выполняемый контекст ввода вывода) <-> Операционная система
Ваша программа будет иметь по крайней мере один выполняемый контекст ввода вывода, такой как boost::asio::io_context, boost::asio::thread_pool или 
boost::asio::system_context. Эти контексты ввода выода представляют точки присоединения вашей программы к операционной системе.

boost::asio::io_ontext io_context;

чтобы произовдить операции ввода вывода необходим объект, к примеру TCP сокет. 

boost::asio::ip::tcp::socket socket(io_context);

При выполнении операции последовательного подключения происходит следующая последовательность событий:
    1. Вааш программа инициализирует соединение вызывая функцию connect():
        socket.connect(server_endpoint);
    2. Объект ввода вывода возвращает запрос к i/o execution context(далее исполнительный контекст).
    3. Исполнительный контекст производит вызовы ОС чтобы выполнить операции подключения.
    4. Операционная система возвращает результаты выполнения операций исполнительному контектсту
    5. Исполнительный контекст переводит все ошибки при выполнении операции в объекты типа  boost::system::error_code.
        Значение error_code может быть сравнено со специальным значением. Если error_code = false - никаких ошибок не произошло.
        Результат возвращается к объекту ввода вывода.
    6. Объект ввода вывода выбрасывает исключение типа  boost::system::system_error если операция провалилась. Если  операция инициации подключения
        произведена следующим образом:
            boost::system::error_code ec;
            socket.connect(server_endpoint, ec);
        то переменная error_code ec будет содержать результат выполнения операции и исключение не будет выброшено.
    
Когда используются асинхронные операции, другая последовательность событий используется:
    1. Ваша программа инициализирует операцию соединения вызовом объекта ввода, вывода.
            socket.async_connect(server_endpoint, your_completion_handler);
        Где your_completion_handler функция или функциональный объект с обработчиком ошибок:
            void your_completion_handler(const boost::system::error_code& ec);
        Точная сигнатура зависит от операций которые вам требуется выполнить. В справочной документации имеется соответствующая форма для каждой операции.
    2. Объект ввода вывода возвращает запрос к исполнительному контектсту.
    3. Исполнительный контекст отправляет сигнал операционной системе, о том, что необходимо создать многопоточное соединение. Время проходит. (В однопоточном
        варианте это ожидание длилось бы до окончания подключения)
    4. Операционная система сигнализирует о том, что операция присоединения была завершена размещением результатов в очередь, результаты готовы для того, 
    что-бы исполнительный контекст обработал их.